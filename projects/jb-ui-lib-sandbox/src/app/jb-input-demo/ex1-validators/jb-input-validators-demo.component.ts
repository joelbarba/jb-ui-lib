import {AfterViewInit, Component, OnInit} from '@angular/core';
import {JbGrowlService} from '../../../../../jb-ui-lib/src/lib/jb-growl/jb-growl.service';
import {IjbInputCtrl} from '../../../../../jb-ui-lib/src/lib/jb-input/jb-input.component';
import {Router} from '@angular/router';
import {dCopy} from '../../../../../jb-ui-lib/src/lib/jb-prototypes/deep-copy';

@Component({
  selector: 'app-jb-input-validators-demo',
  templateUrl: './jb-input-validators-demo.component.html',
  styleUrls: ['./jb-input-validators-demo.component.scss']
})
export class JbInputValidatorsDemoComponent implements OnInit, AfterViewInit {

  constructor(
    public growl: JbGrowlService,
    public router: Router,
  ) {}

  public val1;
  public isLinked = true;
  public inputRef: IjbInputCtrl; // jb-input controller object (ctrlObject)
  public innerInput;

  public manualErrorEx1 = `inputCtrl.removeError()`;
  public manualErrorEx2 = `inputCtrl.addError({ label: 'wroooong!' })`;
  public manualErrorEx3 = `public inputCtrl: IjbInputCtrl = {};`;


  // ---- This is the logic to manage autogenerated code example ----
  public brStr = `\n`;
  public bsStr = `\n          `;
  public customCompCode = ``;
  public valCompCode = '';
  public valEx: any = {
    hasErrOnPristine: true, isDisabled: false, errorPos: '', errorPosOpts : [
      { id: 'top-right',    text: 'top-right',  },
      { id: 'bottom-left',  text: 'bottom-left',   },
      { id: 'bottom-right', text: 'bottom-right',  },
    ],
    jbType: 'text', inputTypes: [
      { id: 'text',     text: 'text',     },
      { id: 'number',   text: 'number',   },
      { id: 'password', text: 'password', },
      { id: 'email',    text: 'email',    },
    ],
    hasInvalidIcon: false,  jbInvalidIcon: 'icon-thumbs-down',
    hasValidIcon: false,    jbValidIcon: 'icon-checkmark4',
    hasErrorText: false,    jbErrorText: 'view.common.custom_error',
    hasIcon: false,         jbIcon: 'icon-search', // jbIcon: 'loading',

    isRequired: true,
    isMinLen: false, minLen: 3,
    isMaxLen: false, maxLen: 5,
    hasPattern: false, pattern: '[A-Za-z]{2,8}',
    hasValidType: false, valType: null, valTypes: [
      { id: 'integer',  text: 'integer',  },
      { id: 'number',   text: 'number',   },
      { id: 'decimal',  text: 'decimal',  },
      { id: 'email',    text: 'email',    },
    ],
    jbValMatchVal: 'AAA',
    hasValidIf: false,
    hasjbValidator: false,
    hasAsyncVal: false,
    hasManualErr: false
  };

  ngOnInit() {
    this.upComp();
  }
  ngAfterViewInit() {} // console.log('EXT - ngAfterViewInit');


  public upComp = () => {
    this.valCompCode = `<jb-input #jbInputRef="ngModel"`;
    this.valCompCode += this.bsStr + `[(ngModel)]="myVariable"`;
    if (this.valEx.hasErrOnPristine)  { this.valCompCode += this.bsStr + `[jbErrorOnPristine]="true"`; }
    if (this.valEx.isDisabled)        { this.customCompCode += this.bsStr + `[jbDisabled]="true"`; }
    if (this.valEx.errorPos)          { this.valCompCode += this.bsStr + `jbErrorPos="${this.valEx.errorPos}"`; }
    if (this.valEx.inputType !== 'text') { this.customCompCode += this.bsStr + `jbType="${this.valEx.inputType}"`; }

    if (this.valEx.hasInvalidIcon)  { this.valCompCode += this.bsStr + `jbInvalidIcon="${this.valEx.jbInvalidIcon}"`; }
    if (this.valEx.hasValidIcon)    { this.valCompCode += this.bsStr + `jbValidIcon="${this.valEx.jbValidIcon}"`; }
    if (this.valEx.hasErrorText)    { this.valCompCode += this.bsStr + `jbErrorText="${this.valEx.jbErrorText}"`; }
    if (this.valEx.hasIcon)         { this.valCompCode += this.bsStr + `jbIcon="${this.valEx.jbIcon}"`; }

    if (this.valEx.isRequired)  { this.valCompCode += this.bsStr + `jbRequired="true"`; }
    if (this.valEx.isMinLen)    { this.valCompCode += this.bsStr + `jbMinlength="${this.valEx.minLen}"`; }
    if (this.valEx.isMaxLen)    { this.valCompCode += this.bsStr + `jbMaxlength="${this.valEx.maxLen}"`; }
    if (this.valEx.valType)     { this.valCompCode += this.bsStr + `jbValidType="${this.valEx.valType}"`; }
    if (this.valEx.hasPattern)  { this.valCompCode += this.bsStr + `jbPattern="${this.valEx.pattern}"`; }
    if (this.valEx.hasValidIf)  { this.valCompCode += this.bsStr + `[jbValidIf]="val1 === 'AAA'"`; }
    if (this.valEx.hasjbValidator) { this.valCompCode += this.bsStr + `[jbValidator]="jbValidatorFn"`; }

    if (this.valEx.hasManualErr) { this.valCompCode += this.bsStr + `(jbOnLoaded)="ctrl = $event"`; }

    this.valCompCode += (`>` + this.brStr + `</jb-input>`);

    if (this.valEx.hasManualErr) {
      this.valCompCode += `\n \n public ctrl: IjbInputCtrl; // jbInput controller object\n`;
      this.valCompCode += ` ctrl.addError({ label: 'manual error here' });\n`;
      this.valCompCode += ` ctrl.removeError();\n`;
    }


    // This is just to avoid the ExpressionChangedAfterItHasBeenCheckedError on the view
    if (this.inputRef) {
      this.innerInput = dCopy(this.inputRef['inputCtrl']);
      setTimeout(() => this.innerInput = this.inputRef['inputCtrl']);
    }
  };



  reLink = () => {
    this.isLinked = false;
    setTimeout(() => this.isLinked = true, 500);
  };

  public jbValidatorFn = (value, ctrl) => {
    return (value === this.valEx.jbValMatchVal) ? null : { label : 'wrooong' };
  };



}



